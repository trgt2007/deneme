/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumberish,
  BytesLike,
  FunctionFragment,
  Result,
  Interface,
  AddressLike,
  ContractRunner,
  ContractMethod,
  Listener,
} from "ethers";
import type {
  TypedContractEvent,
  TypedDeferredTopicFilter,
  TypedEventLog,
  TypedListener,
  TypedContractMethod,
} from "../../../common";

export declare namespace IPoolConfigurator {
  export type ConfigureReserveInputStruct = {
    aTokenImpl: AddressLike;
    stableDebtTokenImpl: AddressLike;
    variableDebtTokenImpl: AddressLike;
    underlyingAssetDecimals: BigNumberish;
    interestRateStrategyAddress: AddressLike;
    underlyingAsset: AddressLike;
    treasury: AddressLike;
    incentivesController: AddressLike;
    aTokenName: string;
    aTokenSymbol: string;
    variableDebtTokenName: string;
    variableDebtTokenSymbol: string;
    stableDebtTokenName: string;
    stableDebtTokenSymbol: string;
    params: BytesLike;
  };

  export type ConfigureReserveInputStructOutput = [
    aTokenImpl: string,
    stableDebtTokenImpl: string,
    variableDebtTokenImpl: string,
    underlyingAssetDecimals: bigint,
    interestRateStrategyAddress: string,
    underlyingAsset: string,
    treasury: string,
    incentivesController: string,
    aTokenName: string,
    aTokenSymbol: string,
    variableDebtTokenName: string,
    variableDebtTokenSymbol: string,
    stableDebtTokenName: string,
    stableDebtTokenSymbol: string,
    params: string
  ] & {
    aTokenImpl: string;
    stableDebtTokenImpl: string;
    variableDebtTokenImpl: string;
    underlyingAssetDecimals: bigint;
    interestRateStrategyAddress: string;
    underlyingAsset: string;
    treasury: string;
    incentivesController: string;
    aTokenName: string;
    aTokenSymbol: string;
    variableDebtTokenName: string;
    variableDebtTokenSymbol: string;
    stableDebtTokenName: string;
    stableDebtTokenSymbol: string;
    params: string;
  };
}

export interface IPoolConfiguratorInterface extends Interface {
  getFunction(
    nameOrSignature:
      | "initReserves"
      | "setBorrowCap"
      | "setLiquidationBonus"
      | "setReserveActive"
      | "setReserveBorrowing"
      | "setReserveFactor"
      | "setReserveFreeze"
      | "setSupplyCap"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "initReserves",
    values: [IPoolConfigurator.ConfigureReserveInputStruct[]]
  ): string;
  encodeFunctionData(
    functionFragment: "setBorrowCap",
    values: [AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "setLiquidationBonus",
    values: [AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "setReserveActive",
    values: [AddressLike, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "setReserveBorrowing",
    values: [AddressLike, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "setReserveFactor",
    values: [AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "setReserveFreeze",
    values: [AddressLike, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "setSupplyCap",
    values: [AddressLike, BigNumberish]
  ): string;

  decodeFunctionResult(
    functionFragment: "initReserves",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setBorrowCap",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setLiquidationBonus",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setReserveActive",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setReserveBorrowing",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setReserveFactor",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setReserveFreeze",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setSupplyCap",
    data: BytesLike
  ): Result;
}

export interface IPoolConfigurator extends BaseContract {
  connect(runner?: ContractRunner | null): IPoolConfigurator;
  waitForDeployment(): Promise<this>;

  interface: IPoolConfiguratorInterface;

  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  on<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  once<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  once<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>;
  removeAllListeners<TCEvent extends TypedContractEvent>(
    event?: TCEvent
  ): Promise<this>;

  initReserves: TypedContractMethod<
    [input: IPoolConfigurator.ConfigureReserveInputStruct[]],
    [void],
    "nonpayable"
  >;

  setBorrowCap: TypedContractMethod<
    [asset: AddressLike, borrowCap: BigNumberish],
    [void],
    "nonpayable"
  >;

  setLiquidationBonus: TypedContractMethod<
    [asset: AddressLike, bonus: BigNumberish],
    [void],
    "nonpayable"
  >;

  setReserveActive: TypedContractMethod<
    [asset: AddressLike, active: boolean],
    [void],
    "nonpayable"
  >;

  setReserveBorrowing: TypedContractMethod<
    [asset: AddressLike, enabled: boolean],
    [void],
    "nonpayable"
  >;

  setReserveFactor: TypedContractMethod<
    [asset: AddressLike, reserveFactor: BigNumberish],
    [void],
    "nonpayable"
  >;

  setReserveFreeze: TypedContractMethod<
    [asset: AddressLike, freeze: boolean],
    [void],
    "nonpayable"
  >;

  setSupplyCap: TypedContractMethod<
    [asset: AddressLike, supplyCap: BigNumberish],
    [void],
    "nonpayable"
  >;

  getFunction<T extends ContractMethod = ContractMethod>(
    key: string | FunctionFragment
  ): T;

  getFunction(
    nameOrSignature: "initReserves"
  ): TypedContractMethod<
    [input: IPoolConfigurator.ConfigureReserveInputStruct[]],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "setBorrowCap"
  ): TypedContractMethod<
    [asset: AddressLike, borrowCap: BigNumberish],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "setLiquidationBonus"
  ): TypedContractMethod<
    [asset: AddressLike, bonus: BigNumberish],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "setReserveActive"
  ): TypedContractMethod<
    [asset: AddressLike, active: boolean],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "setReserveBorrowing"
  ): TypedContractMethod<
    [asset: AddressLike, enabled: boolean],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "setReserveFactor"
  ): TypedContractMethod<
    [asset: AddressLike, reserveFactor: BigNumberish],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "setReserveFreeze"
  ): TypedContractMethod<
    [asset: AddressLike, freeze: boolean],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "setSupplyCap"
  ): TypedContractMethod<
    [asset: AddressLike, supplyCap: BigNumberish],
    [void],
    "nonpayable"
  >;

  filters: {};
}
