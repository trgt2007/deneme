"use strict";
/**
 * @title ArbitrageEngine - Arbitraj Motoru
 * @author Flashloan Arbitrage Bot Sistemi
 * @notice Ana arbitraj motoru - fiyat analizi ve karar verme sistemi
 * @dev Multi-thread desteƒüi ile y√ºksek performanslƒ± arbitraj motoru
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ArbitrageEngine = void 0;
exports.createDefaultEngine = createDefaultEngine;
const events_1 = require("events");
const ethers_1 = require("ethers");
const Logger_1 = require("../utils/Logger");
const PriceMonitor_1 = require("../monitors/PriceMonitor");
const GasMonitor_1 = require("../monitors/GasMonitor");
const LiquidityMonitor_1 = require("../monitors/LiquidityMonitor");
const ProfitCalculator_1 = require("./ProfitCalculator");
const FlashLoanExecutor_1 = require("./FlashLoanExecutor");
const DEXAggregator_1 = require("../dex/DEXAggregator");
const NotificationService_1 = require("../services/NotificationService");
const DatabaseService_1 = require("../services/DatabaseService");
const CircuitBreaker_1 = require("../risk/CircuitBreaker");
const PositionManager_1 = require("../risk/PositionManager");
// ========================================
// üöÄ ARBITRAGE ENGINE CLASS - T√ºrk√ße Dok√ºmantasyon
// ========================================
/**
 * ArbitrageEngine - Ana Arbitraj Motoru
 *
 * Piyasadaki arbitraj fƒ±rsatlarƒ±nƒ± tespit eder ve otomatik olarak i≈ülem ger√ßekle≈ütirir.
 * Multi-thread desteƒüi ile y√ºksek performanslƒ± √ßalƒ±≈üƒ±r.
 *
 * √ñzellikler:
 * - Real-time fiyat monit√∂r√º
 * - Multi-DEX kar≈üƒ±la≈ütƒ±rmasƒ±
 * - Risk y√∂netimi
 * - Otomatik flashloan y√∂netimi
 * - Detaylƒ± performans metrikleri
 */
class ArbitrageEngine extends events_1.EventEmitter {
    // ============ Private Properties ============
    config;
    logger;
    // Monit√∂rler
    priceMonitor;
    gasMonitor;
    liquidityMonitor;
    // Ana Servisler
    profitCalculator;
    flashLoanExecutor;
    dexAggregator;
    notificationService;
    databaseService;
    // Risk Y√∂netimi
    circuitBreaker;
    positionManager;
    // Durum Y√∂netimi
    isRunning = false;
    isPaused = false;
    workers = [];
    stats;
    lastOpportunities = [];
    // Timers
    scanTimer = null;
    metricsTimer = null;
    /**
     * Constructor - Arbitraj Motoru Ba≈ülatƒ±cƒ±
     * @param config - Motor konfig√ºrasyonu
     */
    constructor(config = {}) {
        super();
        this.config = { ...this.getDefaultConfig(), ...config };
        this.logger = Logger_1.Logger;
        // Servisleri ba≈ülat
        this.priceMonitor = new PriceMonitor_1.PriceMonitor({});
        this.gasMonitor = new GasMonitor_1.GasMonitor({});
        this.liquidityMonitor = new LiquidityMonitor_1.LiquidityMonitor({}, {});
        this.profitCalculator = new ProfitCalculator_1.ProfitCalculator({});
        this.flashLoanExecutor = new FlashLoanExecutor_1.FlashLoanExecutor({});
        this.dexAggregator = new DEXAggregator_1.DEXAggregator({});
        this.notificationService = new NotificationService_1.NotificationService({});
        this.databaseService = new DatabaseService_1.DatabaseService({});
        this.circuitBreaker = new CircuitBreaker_1.CircuitBreaker({});
        this.positionManager = new PositionManager_1.PositionManager({});
        // ƒ∞statistikleri ba≈ülat
        this.stats = this.getInitialStats();
        this.logger.info('üöÄ Arbitraj motoru ba≈ülatƒ±ldƒ±', {
            config: this.config,
            timestamp: Date.now()
        });
    }
    // ========================================
    // üéØ ANA KONTROL METODlarƒ±
    // ========================================
    /**
     * Motoru Ba≈ülat
     * Arbitraj taramaya ba≈ülar
     */
    async start() {
        try {
            if (this.isRunning) {
                this.logger.warn('‚ö†Ô∏è Motor zaten √ßalƒ±≈üƒ±yor');
                return;
            }
            this.logger.info('üü¢ Arbitraj motoru ba≈ülatƒ±lƒ±yor...');
            // Servisleri ba≈ülat
            await this.initializeServices();
            // Monit√∂rleri ba≈ülat
            await this.startMonitoring();
            // Worker'larƒ± ba≈ülat (multi-thread aktifse)
            if (this.config.enableMultiThread) {
                await this.startWorkers();
            }
            // Ana tarama d√∂ng√ºs√ºn√º ba≈ülat
            this.startScanningLoop();
            // Metrik toplama ba≈ülat
            if (this.config.metricsEnabled) {
                this.startMetricsCollection();
            }
            this.isRunning = true;
            this.isPaused = false;
            this.logger.info('‚úÖ Arbitraj motoru ba≈üarƒ±yla ba≈ülatƒ±ldƒ±');
            this.emit('started', { timestamp: Date.now() });
        }
        catch (error) {
            this.logger.error('‚ùå Motor ba≈ülatma hatasƒ±:', error);
            throw error;
        }
    }
    /**
     * Motoru Durdur
     * G√ºvenli ≈üekilde motoru kapatƒ±r
     */
    async stop() {
        try {
            this.logger.info('üî¥ Arbitraj motoru durduruluyor...');
            this.isRunning = false;
            // Timer'larƒ± durdur
            if (this.scanTimer) {
                clearInterval(this.scanTimer);
                this.scanTimer = null;
            }
            if (this.metricsTimer) {
                clearInterval(this.metricsTimer);
                this.metricsTimer = null;
            }
            // Worker'larƒ± durdur
            await this.stopWorkers();
            // Monit√∂rleri durdur
            await this.stopMonitoring();
            // Servisleri temizle
            await this.cleanupServices();
            this.logger.info('‚úÖ Arbitraj motoru ba≈üarƒ±yla durduruldu');
            this.emit('stopped', { timestamp: Date.now() });
        }
        catch (error) {
            this.logger.error('‚ùå Motor durdurma hatasƒ±:', error);
            throw error;
        }
    }
    /**
     * Motoru Duraklat
     * Ge√ßici olarak taramayƒ± durdurur
     */
    async pause() {
        this.isPaused = true;
        this.logger.info('‚è∏Ô∏è Arbitraj motoru duraklatƒ±ldƒ±');
        this.emit('paused', { timestamp: Date.now() });
    }
    /**
     * Motoru Devam Ettir
     * Duraklatƒ±lmƒ±≈ü motoru yeniden ba≈ülatƒ±r
     */
    async resume() {
        this.isPaused = false;
        this.logger.info('‚ñ∂Ô∏è Arbitraj motoru devam etti');
        this.emit('resumed', { timestamp: Date.now() });
    }
    /**
     * Arbitraj Fƒ±rsatƒ± Ara
     * Piyasadaki fƒ±rsatlarƒ± tarar ve analiz eder
     */
    async scanForOpportunities() {
        try {
            if (!this.isRunning || this.isPaused) {
                return [];
            }
            // Circuit breaker kontrol√º
            const breakerState = this.circuitBreaker.getState();
            if (breakerState.isTripped) {
                this.logger.warn('üîí Circuit breaker aktif, tarama atlanƒ±yor');
                return [];
            }
            // Piyasa ko≈üullarƒ±nƒ± kontrol et
            const marketConditions = await this.getMarketConditions();
            if (!this.isMarketSuitable(marketConditions)) {
                this.logger.debug('üìä Piyasa ko≈üullarƒ± uygun deƒüil');
                return [];
            }
            // Token √ßiftlerini al
            const tokenPairs = await this.getActiveTokenPairs();
            // Fƒ±rsatlarƒ± tara
            const opportunities = [];
            for (const pair of tokenPairs) {
                try {
                    const pairOpportunities = await this.scanTokenPair(pair);
                    opportunities.push(...pairOpportunities);
                }
                catch (error) {
                    this.logger.error(`Token √ßifti tarama hatasƒ± ${pair.token0.symbol}/${pair.token1.symbol}:`, error);
                }
            }
            // Fƒ±rsatlarƒ± filtrele ve sƒ±rala
            const filteredOpportunities = await this.filterAndRankOpportunities(opportunities);
            this.lastOpportunities = filteredOpportunities;
            this.stats.totalOpportunities += filteredOpportunities.length;
            if (filteredOpportunities.length > 0) {
                this.logger.info(`üéØ ${filteredOpportunities.length} arbitraj fƒ±rsatƒ± tespit edildi`);
                this.emit('opportunitiesFound', filteredOpportunities);
            }
            return filteredOpportunities;
        }
        catch (error) {
            this.logger.error('‚ùå Fƒ±rsat tarama hatasƒ±:', error);
            return [];
        }
    }
    /**
     * Arbitraj ƒ∞≈ülemi Ger√ßekle≈ütir
     * En iyi fƒ±rsatƒ± se√ßer ve i≈ülem yapar
     */
    async executeArbitrage(opportunity) {
        const startTime = Date.now();
        try {
            this.logger.info('‚ö° Arbitraj i≈ülemi ba≈ülatƒ±lƒ±yor', {
                opportunityId: opportunity.id,
                expectedProfit: ethers_1.ethers.formatEther(opportunity.expectedProfit),
                route: opportunity.route.map(r => `${r.exchange}: ${r.tokenIn} -> ${r.tokenOut}`)
            });
            // Circuit breaker son kontrol
            const breakerCheck = await this.circuitBreaker.checkBeforeTransaction(opportunity.expectedProfit, Number(opportunity.gasEstimate), opportunity.slippage);
            if (!breakerCheck.allowed) {
                return {
                    success: false,
                    error: breakerCheck.reason,
                    opportunity,
                    executionTime: Date.now() - startTime
                };
            }
            // Position manager kontrol√º - mock implementation
            const positionCheck = { allowed: true, reason: '' };
            if (!positionCheck.allowed) {
                return {
                    success: false,
                    error: positionCheck.reason,
                    opportunity,
                    executionTime: Date.now() - startTime
                };
            }
            // Flashloan ile arbitraj i≈ülemini ger√ßekle≈ütir - mock implementation
            const result = {
                success: true,
                transactionHash: '0x123...',
                gasUsed: BigInt(300000),
                gasPrice: BigInt(20000000000), // 20 gwei
                profit: opportunity.expectedProfit
            };
            // Sonucu i≈üle
            const executionResult = {
                ...result,
                opportunity,
                executionTime: Date.now() - startTime
            };
            // ƒ∞statistikleri g√ºncelle
            await this.updateStats(executionResult);
            // Circuit breaker'a bildir
            await this.circuitBreaker.checkAfterTransaction({
                success: result.success,
                profit: result.profit || 0n,
                gasUsed: result.gasUsed || 0n,
                gasPrice: Number(result.gasPrice || 0n),
                slippage: opportunity.slippage
            });
            // Position manager'ƒ± g√ºncelle
            if (result.success && result.profit) {
                // Mock position update
                console.log('Position updated:', opportunity.token0, result.profit);
            }
            // Bildirim g√∂nder
            if (this.config.enableNotifications) {
                await this.sendExecutionNotification(executionResult);
            }
            // Veritabanƒ±na kaydet - mock implementation
            console.log('Execution result saved:', executionResult);
            this.emit('executionCompleted', executionResult);
            return executionResult;
        }
        catch (error) {
            this.logger.error('‚ùå Arbitraj i≈ülemi hatasƒ±:', error);
            const errorResult = {
                success: false,
                error: error instanceof Error ? error.message : 'Bilinmeyen hata',
                opportunity,
                executionTime: Date.now() - startTime
            };
            await this.updateStats(errorResult);
            this.emit('executionFailed', errorResult);
            return errorResult;
        }
    }
    // ========================================
    // üìä DURUM ve METRƒ∞K METODlarƒ±
    // ========================================
    /**
     * Motor Durumunu Al
     */
    getStatus() {
        return {
            isRunning: this.isRunning,
            isPaused: this.isPaused,
            stats: { ...this.stats },
            lastOpportunities: [...this.lastOpportunities]
        };
    }
    /**
     * Detaylƒ± ƒ∞statistikler
     */
    async getDetailedStats() {
        const baseStats = { ...this.stats };
        // Veritabanƒ±ndan detaylƒ± veriler
        // Mock database stats
        const hourlyStats = [];
        const dailyStats = [];
        const tokenStats = [];
        const exchangeStats = [];
        return {
            ...baseStats,
            hourlyStats,
            dailyStats,
            tokenStats,
            exchangeStats
        };
    }
    /**
     * Saƒülƒ±k Kontrol√º
     */
    async healthCheck() {
        const details = [];
        let status = 'HEALTHY';
        const components = {
            engine: this.isRunning ? 'OK' : 'ERROR',
            priceMonitor: 'OK',
            gasMonitor: 'OK',
            liquidityMonitor: 'OK',
            circuitBreaker: 'OK',
            positionManager: 'OK',
            database: 'OK'
        };
        // Motor durumu
        if (!this.isRunning) {
            status = 'CRITICAL';
            details.push('Motor √ßalƒ±≈ümƒ±yor');
        }
        if (this.isPaused) {
            status = status === 'CRITICAL' ? 'CRITICAL' : 'WARNING';
            details.push('Motor duraklatƒ±ldƒ±');
        }
        // Circuit breaker durumu
        const breakerHealth = await this.circuitBreaker.healthCheck();
        if (breakerHealth.status === 'CRITICAL') {
            status = 'CRITICAL';
            components.circuitBreaker = 'ERROR';
            details.push(...breakerHealth.details);
        }
        else if (breakerHealth.status === 'WARNING') {
            status = status === 'CRITICAL' ? 'CRITICAL' : 'WARNING';
            components.circuitBreaker = 'WARNING';
            details.push(...breakerHealth.details);
        }
        return {
            status,
            details,
            uptime: Date.now() - (this.stats.lastUpdate || Date.now()),
            components
        };
    }
    // ========================================
    // üîß √ñZEL YARDIMCI METODlar
    // ========================================
    /**
     * Varsayƒ±lan Konfig√ºrasyon
     */
    getDefaultConfig() {
        return {
            minProfitWei: ethers_1.ethers.parseEther('0.001'), // 0.001 ETH minimum kar
            minProfitPercentage: 0.5, // %0.5 minimum kar y√ºzdesi
            maxGasPrice: ethers_1.ethers.parseUnits('100', 'gwei'), // 100 gwei maksimum gas
            gasMultiplier: 1.2, // %20 gas g√ºvenlik marjƒ±
            scanInterval: 5000, // 5 saniye tarama aralƒ±ƒüƒ±
            maxOpportunities: 10, // Maksimum 10 fƒ±rsat
            timeoutMs: 30000, // 30 saniye timeout
            maxSlippage: 1, // %1 maksimum kayma
            minLiquidity: ethers_1.ethers.parseEther('1'), // 1 ETH minimum likidite
            maxRisk: 70, // 70/100 maksimum risk
            enableMultiThread: true, // Multi-thread aktif
            workerCount: 4, // 4 worker
            batchSize: 50, // 50'li batch'ler
            enableNotifications: true, // Bildirimler aktif
            logLevel: 'info', // Info log seviyesi
            metricsEnabled: true // Metrikler aktif
        };
    }
    /**
     * Ba≈ülangƒ±√ß ƒ∞statistikleri
     */
    getInitialStats() {
        return {
            totalOpportunities: 0,
            successfulTrades: 0,
            failedTrades: 0,
            totalProfit: 0n,
            totalGasSpent: 0n,
            averageExecutionTime: 0,
            winRate: 0,
            uptime: Date.now(),
            lastUpdate: Date.now()
        };
    }
    /**
     * Servisleri Ba≈ülat
     */
    async initializeServices() {
        // Servislerin ba≈ülatƒ±lmasƒ± stub olarak implement edildi
        this.logger.info('üîß Servisler ba≈ülatƒ±lƒ±yor...');
    }
    /**
     * Monit√∂rleri Ba≈ülat
     */
    async startMonitoring() {
        // Monit√∂rlerin ba≈ülatƒ±lmasƒ± stub olarak implement edildi
        this.logger.info('üìä Monit√∂rler ba≈ülatƒ±lƒ±yor...');
    }
    /**
     * Worker'larƒ± Ba≈ülat
     */
    async startWorkers() {
        // Worker'larƒ±n ba≈ülatƒ±lmasƒ± stub olarak implement edildi
        this.logger.info('üîÑ Workerlar ba≈ülatƒ±lƒ±yor...');
    }
    /**
     * Ana Tarama D√∂ng√ºs√º
     */
    startScanningLoop() {
        this.scanTimer = setInterval(async () => {
            if (!this.isPaused) {
                const opportunities = await this.scanForOpportunities();
                // En iyi fƒ±rsatƒ± otomatik olarak i≈üle
                if (opportunities.length > 0) {
                    const bestOpportunity = opportunities[0];
                    await this.executeArbitrage(bestOpportunity);
                }
            }
        }, this.config.scanInterval);
    }
    /**
     * Metrik Toplama Ba≈ülat
     */
    startMetricsCollection() {
        this.metricsTimer = setInterval(async () => {
            await this.collectMetrics();
        }, 60000); // Her dakika
    }
    /**
     * Piyasa Ko≈üullarƒ±nƒ± Al
     */
    async getMarketConditions() {
        // Stub implementation
        return {
            gasPrice: ethers_1.ethers.parseUnits('50', 'gwei'),
            networkCongestion: 30,
            volatility: 40,
            liquidityIndex: 80,
            marketSentiment: 'NEUTRAL',
            timestamp: Date.now()
        };
    }
    /**
     * Piyasa Uygunluƒüu Kontrol√º
     */
    isMarketSuitable(conditions) {
        // Basit kontrol - gas fiyatƒ± √ßok y√ºksek deƒüilse uygun
        return conditions.gasPrice <= this.config.maxGasPrice;
    }
    /**
     * Aktif Token √áiftlerini Al
     */
    async getActiveTokenPairs() {
        // Stub implementation - √∂rnek token √ßiftleri
        return [
            {
                token0: {
                    address: '0xA0b86a33E6441E7c8D0e69A33E4D90F02B8AAEE',
                    symbol: 'WETH',
                    decimals: 18
                },
                token1: {
                    address: '0xdAC17F958D2ee523a2206206994597C13D831ec7',
                    symbol: 'USDT',
                    decimals: 6
                },
                exchanges: ['Uniswap', 'Sushiswap'],
                lastUpdate: Date.now()
            }
        ];
    }
    /**
     * Token √áifti Tarama
     */
    async scanTokenPair(pair) {
        // Stub implementation
        return [];
    }
    /**
     * Fƒ±rsatlarƒ± Filtrele ve Sƒ±rala
     */
    async filterAndRankOpportunities(opportunities) {
        return opportunities
            .filter(opp => opp.netProfit >= this.config.minProfitWei)
            .filter(opp => opp.risk <= this.config.maxRisk)
            .sort((a, b) => Number(b.netProfit - a.netProfit))
            .slice(0, this.config.maxOpportunities);
    }
    /**
     * ƒ∞statistikleri G√ºncelle
     */
    async updateStats(result) {
        if (result.success) {
            this.stats.successfulTrades++;
            this.stats.totalProfit += result.profit || 0n;
        }
        else {
            this.stats.failedTrades++;
        }
        this.stats.totalGasSpent += result.gasUsed || 0n;
        this.stats.winRate = this.stats.successfulTrades / (this.stats.successfulTrades + this.stats.failedTrades);
        this.stats.lastUpdate = Date.now();
    }
    /**
     * ƒ∞≈ülem Bildirimi G√∂nder
     */
    async sendExecutionNotification(result) {
        if (result.success) {
            await this.notificationService.sendAlert('ARBITRAGE_SUCCESS', {
                profit: result.profit,
                gasUsed: result.gasUsed,
                executionTime: result.executionTime
            });
        }
        else {
            await this.notificationService.sendAlert('ARBITRAGE_FAILED', {
                error: result.error,
                opportunityId: result.opportunity.id
            });
        }
    }
    /**
     * Worker'larƒ± Durdur
     */
    async stopWorkers() {
        for (const worker of this.workers) {
            await worker.terminate();
        }
        this.workers = [];
    }
    /**
     * Monit√∂rleri Durdur
     */
    async stopMonitoring() {
        // Monit√∂rlerin durdurulmasƒ± stub olarak implement edildi
        this.logger.info('üìä Monit√∂rler durduruluyor...');
    }
    /**
     * Servisleri Temizle
     */
    async cleanupServices() {
        await this.circuitBreaker.cleanup();
        this.logger.info('üßπ Servisler temizlendi');
    }
    /**
     * Metrik Toplama
     */
    async collectMetrics() {
        // Basit metrik toplama
        this.stats.uptime = Date.now() - this.stats.uptime;
    }
}
exports.ArbitrageEngine = ArbitrageEngine;
/**
 * Varsayƒ±lan Motor Factory
 * Hƒ±zlƒ± ba≈ülatma i√ßin kullanƒ±lƒ±r
 */
function createDefaultEngine() {
    const config = {
        minProfitWei: ethers_1.ethers.parseEther('0.002'), // 0.002 ETH minimum kar
        maxGasPrice: ethers_1.ethers.parseUnits('80', 'gwei'), // 80 gwei maksimum gas
        scanInterval: 3000, // 3 saniye tarama
        enableMultiThread: false, // Basit mode
        enableNotifications: false, // Bildirimler kapalƒ±
        metricsEnabled: true // Metrikler a√ßƒ±k
    };
    return new ArbitrageEngine(config);
}
exports.default = ArbitrageEngine;
//# sourceMappingURL=ArbitrageEngine_NEW.js.map